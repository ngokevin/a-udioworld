{
  "name": "parse-css",
  "version": "0.1.0",
  "description": "Standards-based CSS parser, based on the CSS Syntax spec.",
  "keywords": [
    "css",
    "parser"
  ],
  "author": {
    "name": "Tab Atkins",
    "email": "jackalmage@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/tabatkins/parse-css.git"
  },
  "main": "parse-css.js",
  "homepage": "https://github.com/tabatkins/parse-css",
  "contributors": [
    {
      "name": "Tab Atkins Jr."
    }
  ],
  "bugs": {
    "url": "https://github.com/tabatkins/parse-css/issues",
    "email": "jackalmage@gmail.com"
  },
  "dependencies": {},
  "devDependencies": {
    "ansidiff": "^1.0.0"
  },
  "licenses": [
    {
      "type": "CC0",
      "url": "http://github.com/tabatkins/parse-css/raw/master/LICENSE"
    }
  ],
  "scripts": {
    "test": "node tests.js"
  },
  "gitHead": "0d442e04bd4bc6c8086867bf4d336cd536bcb1fe",
  "readme": "Standards-Based CSS Parser\n==========================\n\nThis project implements a standards-based CSS Parser.\nI'm writing the CSS Syntax spec <http://dev.w3.org/csswg/css-syntax/>,\nand need an implementation of it for testing purposes.\n\nThis parser is *not* designed to be fast,\nbut users tell me it's actually rather speedy.\n(I suppose it's faster than running a ton of regexes over a bunch of text!)\nIts structure and coding style are instead meant to be very close to the spec,\nso that it's easy to verify that the code matches the spec\n(and vice versa)\nand to make it easy,\nwhen the spec changes,\nto make the same change in the parser.\n\nIt is intended to fully and completely match browser behavior\n(at least, as much as the final spec does).\n\nThere's a [dingus](https://rawgit.com/tabatkins/parse-css/master/example.html) for testing it out,\nor just quickly checking what some CSS parses into.\n\nUsing the Library\n-----------------\n\nInclude `parse-css.js` in your page.\nThen just call the desired parsing function,\nnamed after the algorithms in the spec:\n`parseAStylesheet()`, etc.\nYou can pass a string\nor a list of tokens\n(such as what's produced by the `tokenize()` function).\nIt'll return an appropriate object,\nas specified by the parsing function.\n\nIf you want to get access to the tokens directly,\ncall `tokenize()` with a string;\nit'll return a list of tokens.\n\nNote that the Syntax spec,\nand thus this parser,\nis *extremely generic*.\nIt doesn't have any specific knowledge of CSS rules,\njust the core syntax,\nso it won't throw out invalid or unknown things,\nand it can't even actually parse the contents of blocks\n(because it doesn't know if they'll contain rules or declarations,\nand those are ambiguous without any context).\nI plan to add some functions that add more CSS knowledge\n(in an extensible way, so it'll retain anything custom that you want to handle yourself),\nbut for now you have to do all the verification and additional parsing yourself.\n\nParsing Functions\n-----------------\n\nHere's the full list of parsing functions.\nThey do exactly what they say in their name,\nbecause they're named exactly the same as the corresponding section of the Syntax spec:\n\n* `parseAStylesheet()`\n* `parseAListOfRules()`\n* `parseARule()`\n* `parseADeclaration()`\n* `parseAListOfDeclarations()`\n* `parseAComponentValue()`\n* `parseAListOfComponentValues()`\n* `parseACommaSeparatedListOfComponentValues()`\n\nCanonicalizing Against A Grammar\n--------------------------------\n\nBy default, the parser can only do so much;\nit knows how to interpret the top-level rules in a stylesheet,\nbut not how to interpret the contents of anything below that.\nThis means that anything nested within a top-level block is left as a bare token stream,\nrequiring you to call the correct parsing function on it.\n\nThe `canonicalize()` function takes a parsing result and a grammar\nand transforms the result accordingly,\nrendering the result into an easier-to-digest form.\n\nA grammar is an object with one of the following four forms:\n\n```js\n{\"stylesheet\":true}\n```\n\n```js\n{\n\t\"qualified\": <grammar>,\n\t\"@foo\": <grammar>,\n\t\"unknown\": <function>\n}\n```\n\n```js\n{\n\t\"declarations\": true,\n\t\"@foo\": <grammar>\n\t\"unknown\": <function>\n}\n```\n\n```js\nnull\n```\n\nA `stylesheet` block contains nothing else;\nit just means that this rule uses the top-level grammar for its contents.\nThis is true, for example, of the `@media` rule.\n\nA `qualified` block means that the rule's contents are qualified rules (style rules) and at-rules.\nThe \"qualified\" key must have another grammar as its value (often `{declarations:true}`).\nAny at-rules that are valid in this context must be listed,\nalso with a grammar for their contents.\nOptionally, the \"unknown\" key can be provided with a function value;\nthis will be called with any unknown at-rules (ones not listed in the grammar)/\nIf it returns a truthy value, it's inserted into the structure with everything else;\nif falsey, the rule is put into the \"errors\" entry of the resulting block for later processing or ignoring.\n\nA `declarations` block means that the rule's contents are declarations and at-rules.\nCurrently, the \"declarations\" key only accepts the value `true`;\neventually it'll allow you to specify what declarations are valid.\nSimilar to `qualified` blocks,\nyou must list what at-rules are allowed,\nand can provide an \"unknown\" function.\n\nA `null` just means that the block has no contents.\nThis is used for at-rules that are statements,\nended with a semicolon rather than a block,\nlike `@import`.\n\nA `CSSGrammar` object is provided with a default grammar for CSS.\nIf you call `canonicalize()` without a grammar,\nthis is used automatically.\nThis is what it currently looks like:\n\n```js\n{\n\tqualified: {declarations:true},\n\t\"@media\": {stylesheet:true},\n\t\"@keyframes\": {qualified:{declarations:true}},\n\t\"@font-face\": {declarations:true},\n\t\"@supports\": {stylesheet:true},\n\t\"@scope\": {stylesheet:true},\n\t\"@counter-style\": {declarations:true},\n\t\"@import\": null,\n\t\"@font-feature-values\": {\n\t\t// No qualified rules actually allowed,\n\t\t// but have to declare it one way or the other.\n\t\tqualified: true,\n\t\t\"@stylistic\": {declarations:true},\n\t\t\"@styleset\": {declarations:true},\n\t\t\"@character-variants\": {declarations:true},\n\t\t\"@swash\": {declarations:true},\n\t\t\"@ornaments\": {declarations:true},\n\t\t\"@annotation\": {declarations:true},\n\t},\n\t\"@viewport\": {declarations:true},\n\t\"@page\": {\n\t\tdeclarations: true,\n\t\t\"@top-left-corner\": {declarations:true},\n\t\t\"@top-left\": {declarations:true},\n\t\t\"@top-center\": {declarations:true},\n\t\t\"@top-right\": {declarations:true},\n\t\t\"@top-right-corner\": {declarations:true},\n\t\t\"@right-top\": {declarations:true},\n\t\t\"@right-middle\": {declarations:true},\n\t\t\"@right-bottom\": {declarations:true},\n\t\t\"@right-bottom-corner\": {declarations:true},\n\t\t\"@bottom-right\": {declarations:true},\n\t\t\"@bottom-center\": {declarations:true},\n\t\t\"@bottom-left\": {declarations:true},\n\t\t\"@bottom-left-corner\": {declarations:true},\n\t\t\"@left-bottom\": {declarations:true},\n\t\t\"@left-center\": {declarations:true},\n\t\t\"@left-top\": {declarations:true},\n\t},\n\t\"@custom-selector\": null,\n\t\"@custom-media\": null\n}\n```\n\nThe return value is a nested structure of objects.\nEach has a \"type\" key, set to either \"stylesheet\", \"qualified-rule\" or \"at-rule\".\nUnless it's a statement at-rule,\neach has a \"rules\" key set to an array of contained rules/declarations.\nAt-rules also have a \"name\" (string) and \"prelude\" (list of tokens for the part before the block).\nQualified rules have a \"declarations\",\nwhich is an object mapping declaration name to value (list of tokens),\nfor ease of use\n(all the declarations are in the `.rules` property already,\nbut this gives you easy access to them by name,\nand only stores the last of each if they're repeated).\n\nNode Integration\n----------------\n\n`parse-css.js` uses the UMD module pattern,\nexporting the parser functions, the `tokenize()` function,\nand all of the classes used by the parser and tokenizer.\n",
  "readmeFilename": "README.md",
  "_id": "parse-css@0.1.0",
  "_shasum": "e7fb1a721688761f743ae9bc214a7ba9e8175cd6",
  "_from": "git://github.com/tabatkins/parse-css.git#0d442e04bd4bc6c",
  "_resolved": "git://github.com/tabatkins/parse-css.git#0d442e04bd4bc6c8086867bf4d336cd536bcb1fe"
}
