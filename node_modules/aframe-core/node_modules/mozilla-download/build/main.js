"use strict";

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { "default": obj }; };

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

module.exports = main;

var ArgumentParser = require("argparse").ArgumentParser;

var debug = _interopRequire(require("debug"));

var detectOS = _interopRequire(require("./detectos"));

var detectURL = _interopRequire(require("./detecturl"));

var download = _interopRequire(require("./download"));

var _extract = require("./extract");

var extract = _extract.extract;
var productDirname = _extract.productDirname;

var readdir = require("mz/fs").readdir;

var buildinfo = _interopRequireWildcard(require("./moz_build_info"));

debug = debug("mozilla-download/main");

var parser = new ArgumentParser({
  version: require("../package").version,
  description: "Utility to download gecko builds from taskcluster index",
  addHelp: false
});

parser.addArgument(["--product"], {
  type: "string",
  help: "Name for gecko build (ie b2g-desktop, mulet)",
  defaultValue: "b2g-desktop"
});

parser.addArgument(["--os"], {
  type: "string",
  help: "OS to download build for (ie linux-x86_64)",
  defaultValue: detectOS()
});

parser.addArgument(["--branch"], {
  type: "string",
  defaultValue: "mozilla-central"
});

parser.addArgument(["--debug"], {
  type: "int",
  defaultValue: 0
});

parser.addArgument(["--file-suffix"], {
  type: "string",
  dest: "fileSuffix"
});

parser.addArgument(["dest"], {
  type: "string"
});

function main() {
  var args = arguments[0] === undefined ? parser.parseArgs() : arguments[0];
  var dirname, contents, url, path, product, extractOpts, parts, os;
  return regeneratorRuntime.async(function main$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        dirname = productDirname[args.product];
        context$1$0.prev = 1;
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return readdir(args.dest);

      case 5:
        contents = context$1$0.sent;

        if (!(dirname && contents && contents.indexOf(dirname) !== -1)) {
          context$1$0.next = 9;
          break;
        }

        // dest dir includes product
        debug("Found " + dirname + " at dest " + args.dest);
        return context$1$0.abrupt("return");

      case 9:
        context$1$0.next = 13;
        break;

      case 11:
        context$1$0.prev = 11;
        context$1$0.t1 = context$1$0["catch"](2);

      case 13:

        debug("No " + dirname + " found. Will download to " + args.dest);
        context$1$0.next = 16;
        return detectURL(args);

      case 16:
        url = context$1$0.sent;

        debug("Artifact url", url);
        context$1$0.next = 20;
        return download(url, args);

      case 20:
        path = context$1$0.sent;

        debug("Download to", path);
        product = args.product;
        extractOpts = { source: path, dest: args.dest, product: product };

        if (args.fileSuffix) {
          parts = args.fileSuffix.split(".");

          extractOpts.filetype = parts[parts.length - 1];
        } else {
          os = args.os;

          extractOpts.filetype = buildinfo.archiveFiletype(os, product);
        }

        context$1$0.next = 27;
        return extract(extractOpts);

      case 27:
        context$1$0.next = 32;
        break;

      case 29:
        context$1$0.prev = 29;
        context$1$0.t2 = context$1$0["catch"](1);

        console.error(context$1$0.t2.toString());

      case 32:
      case "end":
        return context$1$0.stop();
    }
  }, null, this, [[1, 29], [2, 11]]);
}

// Bail if thing exists

// They want the regular old build archive.
//# sourceMappingURL=main.js.map