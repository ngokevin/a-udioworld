"use strict";

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { "default": obj }; };

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

/**
 * Options:
 *
 *   (String) product
 *   (String) os
 *   (String) branch
 *   (String) revision
 *   (String) fileSuffix
 */
module.exports = detectURL;

var taskcluster = _interopRequire(require("taskcluster-client"));

var format = require("url").format;

var buildinfo = _interopRequireWildcard(require("./moz_build_info"));

var TC_CLIENT_OPTS = { timeout: 30 * 1000 };
function detectURL(options) {
  var nsparts, buildname, ns, index, task, queue, _ref, artifacts, os, product, suffix, artifact;

  return regeneratorRuntime.async(function detectURL$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        nsparts = ["buildbot", "branches", options.branch];
        buildname = buildinfo.buildname(options);

        nsparts.push(buildname);
        ns = nsparts.join(".");
        index = new taskcluster.Index(TC_CLIENT_OPTS);
        context$1$0.next = 7;
        return index.findTask(ns);

      case 7:
        task = context$1$0.sent;
        queue = new taskcluster.Queue(TC_CLIENT_OPTS);
        context$1$0.next = 11;
        return queue.listLatestArtifacts(task.taskId);

      case 11:
        _ref = context$1$0.sent;
        artifacts = _ref.artifacts;
        os = options.os;
        product = options.product;
        suffix = !!options.fileSuffix ? options.fileSuffix : buildinfo.archiveFileSuffix(product, os);
        artifact = artifacts.find(function (art) {
          return art.name.indexOf(suffix) !== -1;
        });

        if (artifact) {
          context$1$0.next = 19;
          break;
        }

        return context$1$0.abrupt("return", Promise.reject(new Error("Could not find appropriate artifact")));

      case 19:
        return context$1$0.abrupt("return", format({
          protocol: "https",
          host: "queue.taskcluster.net",
          pathname: "/v1/task/" + task.taskId + "/artifacts/" + artifact.name
        }));

      case 20:
      case "end":
        return context$1$0.stop();
    }
  }, null, this);
}

// Figure out the appropriate index namespace.

// Find task in namespace.

// List task artifacts.

// Default to downloading the build archive for our os.

// Filter through namespace artifacts.

// Url for build is
// https://queue.taskcluster.net/v1/task/{taskId}/artifacts/{artifact}
//# sourceMappingURL=detecturl.js.map